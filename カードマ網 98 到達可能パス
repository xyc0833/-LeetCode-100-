カードマ網 98 到達可能パス
#include <iostream>
#include <vector>
using namespace std;
vector<vector<int>> result; // 条件を満たすパスを収集
vector<int> path;           // ノード1から終点までのパス

void dfs (const vector<vector<int>>& graph, int x, int n) {
    // 現在探索中のノードxが終点nに到達した場合
    if (x == n) { 
        result.push_back(path); // パスを結果リストに追加
        return;
    }
    for (int i = 1; i <= n; i++) { 
        // ノードxから接続されている全ノードを探索
        if (graph[x][i] == 1) { 
            // xと接続しているノードを検出
            path.push_back(i);  // 探索ノードをパスに追加
            dfs(graph, i, n);   // 再帰呼び出しで次層探索
            path.pop_back();    // バックトラック：ノードを取り除く
        }
    }
}

int main() {
    int n, m, s, t;
    cin >> n >> m;

    // ノード番号は1～nなのでn+1の配列を確保
    vector<vector<int>> graph(n + 1, vector<int>(n + 1, 0));

    while (m--) {
        cin >> s >> t;
        // 隣接行列で無向グラフを表現（1はs-t間の辺）
        graph[s][t] = 1;
        graph[t][s] = 1; // 無向グラフ対応追加
    }

    path.push_back(1); // パスは常にノード1から開始
    dfs(graph, 1, n);  // 探索開始

    // 結果出力
    if (result.size() == 0) cout << -1 << endl;
    for (const vector<int> &pa : result) {
        for (int i = 0; i < pa.size() - 1; i++) {
            cout << pa[i] << " ";
        }
        cout << pa[pa.size() - 1]  << endl;
    }
}


#include<bits/stdc++.h>
using namespace std;
vector<vector<int>> result;
vector<int> path;
//1 确定递归的参数
//x 代表目前的结点 n 代表终点
void dfs(vector<vector<int>>& graph,int x,int n){
    //2 确定终止条件
    if(x == n){
        result.push_back(path);
        return ;
    }
    //3 确定单次操作所需要做的事情
    //遍历结点x的所有结点
    for(int i=1;i<=n;i++){
        if(graph[x][i] == 1){
            path.push_back(i);
            dfs(graph,i,n);
            path.pop_back();
        }
    }
}

int main(){
    int n,m,s,t;
    cin>>n>>m;
    //图的存储 采用邻接矩阵存储
    vector<vector<int>> graph(n+1,vector<int>(n+1,0));

    //因为是后续m行
    while(m--){
        cin>>s>>t;
        graph[s][t] = 1;
    }
    //无论什么路径都是从节点0出发
    path.push_back(1);
    dfs(graph,1,n);

    //输出结果
    if(result.size() == 0) cout<<-1<<endl;
    for(const vector<int>& pa : result){
        for(int i = 0;i<pa.size()-1;i++){
            cout<<pa[i]<<' ';
        }
        cout<<pa[pa.size()-1]<<endl;
    }
    
    
    return 0;
}
